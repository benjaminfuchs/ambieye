# --------------------------------------------------------------------------
# Class definition of DominantColorThread - this thread calculates the color
#
# Author: Benjamin Fuchs
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

from threading import Thread
import inspect
import os
import cv2
import webcolors
import numpy as np
from sklearn.cluster import KMeans
from collections import Counter


class DominantColorThread(Thread):
    """ DominantColorThread thread """

    # initialize object   ----------------------------------------------------

    def __init__(self, settings, videoStreamThread, screenThread):
        """ Constructor """

        super(DominantColorThread, self).__init__(name="DominantColorThread")
        self._settings = settings
        self._stop_event = settings.stop_event
        self._videoStreamThread = videoStreamThread
        self._screenThread = screenThread

    # run the thread   -------------------------------------------------------

    def run(self):
        """ run-method of thread """

        self.blink()
        while not self._stop_event.wait(5) and self._settings.get("screen.ready") == "false":
            self._settings.log.msg("DominantColorThread: waiting for screen coordinates...")

        self.blink()
        self._settings.log.msg("DominantColorThread: starting...")
        while not self._stop_event.is_set():
            image = self._videoStreamThread.read()
            x, y, w, h = self._settings.get("screen.coordinates")
            crop_img = image[y:y + h, x:x+w]
            path = os.path.dirname(os.path.abspath(
                inspect.getfile(inspect.currentframe())))
            cv2.imwrite(os.path.join(
                path, "web", "pic", "screen.jpg"), crop_img)
            try:
                color = self.get_dominant_color(crop_img)
                self._settings.set("led.color", webcolors.rgb_to_hex(color))
            except Exception as exception:
                self._settings.log.msg(
                    "DominantColorThread: [ERROR] Could not get dominant color! (%s)" % str(exception))

        self.blink()
        self._settings.log.msg("DominantColorThread: shutdown")

    def blink(self):
        self._settings.set("led.color", webcolors.rgb_to_hex([0, 0, 0]))
        self._stop_event.wait(0.3)
        self._settings.set("led.color", webcolors.rgb_to_hex([255, 255, 255]))
        self._stop_event.wait(0.3)
        self._settings.set("led.color", webcolors.rgb_to_hex([0, 0, 0]))

    def get_dominant_color(self, bgr_image, k=1, image_processing_size=1):
        """
        takes an image as input and returns the dominant color as an rgb array

        dominant color is found by performing k means on the pixel colors and returning the centroid
        of the largest cluster

        processing time is sped up by working with a smaller image; this can be done with the 
        image_processing_size param which takes a tuple of image dims as input
        """
        # convert to HSV; this is a better representation of how we see color
        hsv_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2HSV)

        # resize image if new dims provided
        if image_processing_size is not None:
            hsv_image = cv2.resize(
                hsv_image, (image_processing_size, image_processing_size), interpolation=cv2.INTER_AREA)

        path = os.path.dirname(os.path.abspath(
            inspect.getfile(inspect.currentframe())))
        cv2.imwrite(os.path.join(
            path, "web", "pic", "color.jpg"), hsv_image)

        # reshaping the image to be a list of pixels
        hsv_image = hsv_image.reshape(
            (hsv_image.shape[0] * hsv_image.shape[1], 3))

        # clustering the pixels and assign labels
        clt = KMeans(n_clusters=k)
        labels = clt.fit_predict(hsv_image)

        # counting labels to find most popular
        label_counts = Counter(labels)

        # subset out most popular centroid
        dominant_color = clt.cluster_centers_[
            label_counts.most_common(1)[0][0]]

        # create 1px rgb image from color
        dominant_color = np.uint8([[dominant_color]])
        rgb_image = cv2.cvtColor(dominant_color, cv2.COLOR_HSV2RGB)

        return rgb_image.tolist()[0][0]
