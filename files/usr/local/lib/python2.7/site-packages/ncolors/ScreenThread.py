import cv2
import collections
import inspect
import os
from threading import Thread


class ScreenThread(Thread):
    """ DominantColorThread thread """

    DEQUE_LENGHT = 100

    # initialize object   ----------------------------------------------------

    def __init__(self, settings, videoStreamThread):
        """ Constructor """

        super(ScreenThread, self).__init__(name="ScreenThread")
        self._settings = settings
        self._stop_event = settings.stop_event
        self._videoStreamThread = videoStreamThread
        self._ready = False
        self._avg = None
        self._x = collections.deque(maxlen=self.DEQUE_LENGHT)
        self._y = collections.deque(maxlen=self.DEQUE_LENGHT)
        self._w = collections.deque(maxlen=self.DEQUE_LENGHT)
        self._h = collections.deque(maxlen=self.DEQUE_LENGHT)
        self.x = None
        self.y = None
        self.w = None
        self.h = None

    # run the thread   -------------------------------------------------------

    def run(self):
        """ run-method of thread """

        self._settings.log.msg("ScreenThread: starting...")

        while not self._stop_event.wait(1) and not self._videoStreamThread.ready():
            self._settings.log.msg("ScreenThread: waiting for stream...")

        while not self._stop_event.is_set() and not self.ready():
            try:
                self.loop()
                if len(self._x) == self.DEQUE_LENGHT:
                    self._x = self.remove_extrem(self._x)
                    self._y = self.remove_extrem(self._y)
                    self._w = self.remove_extrem(self._w)
                    self._h = self.remove_extrem(self._h)
                    self.x, self.y, self.w, self.h = sum(self._x)/len(self._x), sum(self._y)/len(
                        self._y), sum(self._w)/len(self._w), sum(self._h)/len(self._h)
                    self._settings.log.msg("ScreenThread: screen ready")
                    self._ready = True
            except Exception as exception:
                self._settings.log.msg(
                    "ScreenThread: [ERROR] Could not get screen! (%s)" % str(exception))

        self._settings.log.msg("ScreenThread: shutdown")

    def ready(self):
        if self._ready:
            return True
        return False

    def get_coordinates(self):
        return self.x, self.y, self.w, self.h

    def remove_extrem(self, cord_list):
        for i in range(25):
            cord_list.remove(max(cord_list))
            cord_list.remove(min(cord_list))
        return cord_list

    def loop(self):
        image = self._videoStreamThread.read()
        path = os.path.dirname(os.path.abspath(
            inspect.getfile(inspect.currentframe())))
        cv2.imwrite(os.path.join(
            path, "web", "pic", "screen.jpg"), image)

        # resize the frame, convert it to grayscale, and blur it
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        gray = cv2.GaussianBlur(gray, (21, 21), 0)

        # if the average frame is None, initialize it
        if self._avg is None:
            self._avg = gray.copy().astype("float")

        # accumulate the weighted average between the current frame and
        # previous frames, then compute the difference between the current
        # frame and running average
        frameDelta = cv2.absdiff(gray, cv2.convertScaleAbs(self._avg))
        cv2.accumulateWeighted(gray, self._avg, 0.5)

        # threshold the delta image, dilate the thresholded image to fill
        # in holes, then find contours on thresholded image
        thresh = cv2.threshold(frameDelta, 5, 255,
                               cv2.THRESH_BINARY)[1]
        thresh = cv2.dilate(thresh, None, iterations=2)
        _, cnts, _ = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,
                                      cv2.CHAIN_APPROX_SIMPLE)

        if cnts:
            c = max(cnts, key=cv2.contourArea)
            if cv2.contourArea(c) > 5000:
                x, y, w, h = cv2.boundingRect(c)
                self._x.append(x)
                self._y.append(y)
                self._w.append(w)
                self._h.append(h)
