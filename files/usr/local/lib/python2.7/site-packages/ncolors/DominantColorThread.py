# --------------------------------------------------------------------------
# Class definition of DomiantColorThread - this thread calculates the color
#
# Author: Benjamin Fuchs
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

from threading import Thread
import cv2
from PiVideoStream import PiVideoStream
from Screen import Screen

class DomiantColorThread(Thread):
  """ DomiantColor thread """

  # initialize object   ----------------------------------------------------

  def __init__(self, settings):
    """ Constructor """

    super(DomiantColorThread,self).__init__(name="DomiantColorThread")
    self._settings = settings
    self._stop_event = settings.stop_event

  # run the thread   -------------------------------------------------------

  def run(self):
    """ run-method of thread """

    self._settings.log.msg("DomiantColorThread: running WebDomiantColorThreadThread")

    streamThread = PiVideoStream(self._settings)
    streamThread.start()
    self._stop_event.wait(1)
    screen = Screen()

    old_x, old_y, old_w, old_h = 0, 0, 0, 0
    count = 0
    self.blink()
    self._settings.log.msg("DomiantColorThread: searching screen...")
    while not self._stop_event.wait(0.01):
        image = streamThread.read()
        screen.get_screen_cordinates(image)

        if screen.x < old_x + 10 and screen.x > old_x - 10 and screen.y < old_y + 10 and screen.y > old_y - 10 \
            and screen.w < old_w + 10 and screen.w > old_w - 10 and screen.h < old_h + 10 and screen.h > old_h - 10:
            count = count + 1
        else:
            count = 0
        old_x, old_y, old_w, old_h = screen.x, screen.y, screen.w, screen.h
    
        if count > 50:
            break

    screen.set_border()
    self.blink()
    self._settings.log.msg("DomiantColorThread: found screen")

    while not self._stop_event.wait(0.01):
        image = streamThread.read()
        screen.get_screen_cordinates(image)
        crop_img = image[screen.y:screen.y+screen.h, screen.x:screen.x+screen.w]
        cv2.imwrite("screen.jpg" , crop_img)
        try:
            color = self.get_dominant_color(crop_img, \
                brightness, num_means, processing_size)
        except Exception as exception:
            self._settings.log.msg("DomiantColorThread: [ERROR] Could not get dominant color! (%s)", str(exception))
        self._settings.set("led.color", color)

    self._settings.log.msg("DomiantColorThread: shutdown")
    streamThread.stop()


  def blink(self):
      self._settings.set("led.color", (0, 0, 0))
      self._stop_event.wait(0.2)
      self._settings.set("led.color", (255, 255, 255))
      self._stop_event.wait(0.2)
      self._settings.set("led.color", (0, 0, 0))


  def get_dominant_color(self, bgr_image, brightness=0, k=4, image_processing_size = 25):
      """
      takes an image as input and returns the dominant color as an rgb array
      
      dominant color is found by performing k means on the pixel colors and returning the centroid
      of the largest cluster

      processing time is sped up by working with a smaller image; this can be done with the 
      image_processing_size param which takes a tuple of image dims as input
      """
      # convert to HSV; this is a better representation of how we see color
      hsv_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2HSV)

      h, s, v = cv2.split(hsv_image)

      lim = brightness
      v[v < lim] = 0
      v[v >= lim] -= brightness

      hsv_image = cv2.merge((h, s, v))

      # resize image if new dims provided
      if image_processing_size is not None:
          hsv_image = cv2.resize(hsv_image, (image_processing_size, image_processing_size), interpolation = cv2.INTER_AREA)

      # reshaping the image to be a list of pixels
      hsv_image = hsv_image.reshape((hsv_image.shape[0] * hsv_image.shape[1], 3))

      # clustering the pixels and assign labels
      clt = KMeans(n_clusters = k)
      labels = clt.fit_predict(hsv_image)

      # counting labels to find most popular
      label_counts = Counter(labels)

      # subset out most popular centroid
      dominant_color = clt.cluster_centers_[label_counts.most_common(1)[0][0]]

      # create 1px rgb image from color
      dominant_color = np.uint8([[dominant_color]]) 
      rgb_image = cv2.cvtColor(dominant_color, cv2.COLOR_HSV2RGB)

      return rgb_image.tolist()[0][0]